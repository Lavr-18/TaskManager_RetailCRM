import os
import openai
import json
import re
from datetime import datetime
from dotenv import load_dotenv
from typing import List, Dict, Any

load_dotenv()

# Устанавливаем ключ API из переменных окружения
openai.api_key = os.getenv('OPENAI_API_KEY')


def analyze_comment_with_openai(comment: str) -> List[Dict[str, Any]]:
    """
    Отправляет комментарий на анализ в OpenAI и возвращает список найденных задач
    в виде JSON-объектов.
    """
    if not openai.api_key:
        print("Ошибка: Ключ OpenAI API не установлен.")
        return []

    # Получаем текущую дату и время для промпта
    current_datetime_str = datetime.now().strftime("%Y-%m-%d %H:%M")

    system_prompt = f"""
Ты — продвинутый ассистент, CRM-менеджер-помощник. Твоя основная задача — анализировать комментарии и сообщения, оставленные менеджерами в CRM-системе, и извлекать из них будущие задачи для автоматической постановки.

## Инструкции по анализу
1.  **Роль**: Ты должен найти в тексте только те записи, которые являются явными будущими задачами.
2.  **Игнорирование**: Полностью игнорируй любые записи, которые не требуют будущих действий, например:
    -   Уже произошедшие события (описания прошедших звонков, встреч).
    -   Статусы заказа ("дубль заказа", "закрыл", "продал").
    -   Описания без привязки ко времени ("обратной связи нет", "бросила трубку").
3.  **Год**: Для всех дат используй текущий год (`{datetime.now().year}`), если год не указан в тексте.
4.  **Время**: Если в тексте не указано конкретное время, используй стандартное время 10:00.
5.  **Слова-синонимы**: Слово "кас" является сокращением от "касание" и означает, что нужно связаться с клиентом.

## Строгое правило:
Извлекай задачу **только в том случае, если в комментарии есть явное указание на дату (например, 15.09) или относительный период (например, завтра, через 3 дня)**. Если такой информации нет, верни пустой JSON-массив.

## Формат ответа
Твой ответ должен быть **исключительно** в формате JSON-массива. Каждый объект в массиве должен иметь следующие три поля:
-   `task`: Краткое описание задачи (например, "Перезвонить", "Отправить КП", "Связаться с клиентом").
-   `date_time`: Дата и время выполнения задачи в строгом формате `ГГГГ-ММ-ДД ЧЧ:ММ`. Для относительных дат (`завтра`, `через 3 дня`) используй текущую дату (`{current_datetime_str}`) для расчёта.
-   `marked_line`: Точная строка из исходного текста, которая содержит эту задачу.

Если в тексте нет ни одной подходящей будущей задачи, верни пустой JSON-массив: `[]`.

## Примеры для обучения
**Пример 1 (Задача найдена):**
-   **Входной текст:** "Заказ № 11234\nперезвонить через 3 дня\nотменил заказ"
-   **Ожидаемый JSON-ответ:**
    ```json
    [
      {{
        "task": "Перезвонить",
        "date_time": "2025-09-18 10:00",
        "marked_line": "перезвонить через 3 дня"
      }}
    ]
    ```

**Пример 2 (Несколько задач):**
-   **Входной текст:** "Клиент попросил отправить коммерческое предложение завтра\nнаписать в мессенджер 21.09"
-   **Ожидаемый JSON-ответ:**
    ```json
    [
      {{
        "task": "Отправить коммерческое предложение",
        "date_time": "2025-09-16 10:00",
        "marked_line": "отправить коммерческое предложение завтра"
      }},
      {{
        "task": "Написать в мессенджер",
        "date_time": "2025-09-21 10:00",
        "marked_line": "написать в мессенджер 21.09"
      }}
    ]
    ```

**Пример 3 (Игнорирование):**
-   **Входной текст:** "Встреча 11.09\nнет связи"
-   **Ожидаемый JSON-ответ:**
    ```json
    []
    ```

**Пример 4 (Игнорирование без даты):**
-   **Входной текст:** "ДОСТАВКА КП ГЕОДАР"
-   **Ожидаемый JSON-ответ:**
    ```json
    []
    ```

**Пример 5 (Новое правило: "кас"):**
-   **Входной текст:** "кас 16.09"
-   **Ожидаемый JSON-ответ:**
    ```json
    [
      {{
        "task": "Связаться с клиентом",
        "date_time": "2025-09-16 10:00",
        "marked_line": "кас 16.09"
      }}
    ]
    ```

Твой ответ должен содержать только один JSON-объект, который является массивом.
"""
    try:
        response = openai.chat.completions.create(
            model="gpt-4o-mini",
            response_format={"type": "json_object"},
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": comment}
            ]
        )

        raw_content = response.choices[0].message.content
        print(f"Сырой ответ от OpenAI: ```json\n{raw_content}\n```")

        # Удаляем лишние символы из ответа, если они есть
        clean_content = re.sub(r'```json\n|```', '', raw_content).strip()

        # Загружаем JSON-данные
        parsed_data = json.loads(clean_content)

        # Новая, более надежная логика обработки ответа
        if isinstance(parsed_data, list):
            # Если это массив, фильтруем его
            return [item for item in parsed_data if item.get('task') and item.get('date_time')]
        elif isinstance(parsed_data, dict):
            # Если это словарь, проверяем на пустой ответ или вложенность
            if parsed_data.get('response') is not None:
                # Обработка {"response": []}
                if isinstance(parsed_data.get('response'), list):
                    return [item for item in parsed_data['response'] if item.get('task') and item.get('date_time')]
                else:
                    return []
            # Обработка одиночного объекта {} или {"task": "..."}
            elif parsed_data.get('task') and parsed_data.get('date_time'):
                return [parsed_data]
            else:
                return []
        else:
            print("Ошибка: Неожиданный формат ответа от OpenAI.")
            return []

    except json.JSONDecodeError as e:
        print(f"Ошибка декодирования JSON: {e}. Сырой контент: {clean_content}")
        return []
    except openai.APIError as e:
        print(f"Ошибка при запросе к OpenAI API: {e}")
        return []