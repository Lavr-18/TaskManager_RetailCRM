import os
import openai
import json
import re
from datetime import datetime
from dotenv import load_dotenv
from typing import List, Dict, Any

load_dotenv()

# Устанавливаем ключ API из переменных окружения
openai.api_key = os.getenv('OPENAI_API_KEY')


def analyze_comment_with_openai(comment: str) -> List[Dict[str, Any]]:
    """
    Отправляет комментарий на анализ в OpenAI и возвращает список найденных задач
    в виде JSON-объектов.
    """
    if not openai.api_key:
        print("Ошибка: Ключ OpenAI API не установлен.")
        return []

    # Получаем текущие дату и время для промпта
    current_datetime_str = datetime.now().strftime("%Y-%m-%d %H:%M")

    system_prompt = f"""
Ты — продвинутый ассистент, CRM-менеджер-помощник. Твоя основная задача — анализировать комментарии и сообщения, оставленные менеджерами в CRM-системе, и извлекать из них только **будущие задачи для автоматической постановки для менеджеров по продажам**.

## Инструкции по анализу
1.  **Роль**: Твоя единственная цель — найти в тексте только те записи, которые являются явными будущими задачами для менеджера по продажам.
2.  **Строгое игнорирование**: Полностью игнорируй любые записи, которые не требуют будущих действий, а именно:
    -   Уже произошедшие события (описания прошедших звонков, встреч).
    -   Текущие статусы заказа ("дубль заказа", "закрыл", "продал").
    -   Описания без привязки ко времени ("обратной связи нет", "бросила трубку").
    -   **Задачи для других отделов** (логистика, доставка, склад и т.д.).
3.  **Год**: Для всех дат используй текущий год (`{datetime.now().year}`), если год не указан в тексте.
4.  **Время**: Если в тексте не указано конкретное время, используй текущее время `{current_datetime_str}` и прибавь один час.
    **Важное правило:** Если итоговое время получается после 20:00, перенеси задачу на следующий день на 10:00.
5.  **Слова-синонимы**: Слово "кас" является сокращением от "касание" и означает, что нужно связаться с клиентом. "след кас" - следующее касание.

## СТРОГОЕ И ЖЁСТКОЕ ПРАВИЛО:
Верни пустой массив `[]`, если в комментарии **нет явного и прямого** указания на **будущую** дату или относительный период (например, `25.10`, `завтра`, `через 2 дня`, `во вторник`). Игнорируй всё, что уже произошло или является просто описанием.

## Формат ответа
Твой ответ должен быть **исключительно** в формате JSON-массива. Каждый объект в массиве должен иметь следующие три поля:
-   `task`: Краткое описание задачи (например, "Перезвонить", "Отправить КП", "Связаться с клиентом").
-   `date_time`: Дата и время выполнения задачи в строгом формате `ГГГГ-ММ-ДД ЧЧ:ММ`. Для относительных дат (`завтра`, `через 3 дня`) используй текущую дату (`{current_datetime_str}`) для расчёта.
-   `marked_line`: Точная строка из исходного текста, которая содержит эту задачу.

Если в тексте нет ни одной подходящей будущей задачи, верни пустой JSON-массив: `[]`.

## Примеры для обучения
**Пример 1 (Задача найдена):**
-   **Входной текст:** "Заказ № 11234\nперезвонить через 3 дня\nотменил заказ"
-   **Ожидаемый JSON-ответ:**
    ```json
    [
      {{
        "task": "Перезвонить",
        "date_time": "2025-09-18 10:00",
        "marked_line": "перезвонить через 3 дня"
      }}
    ]
    ```

**Пример 2 (Несколько задач):**
-   **Входной текст:** "Клиент попросил отправить коммерческое предложение завтра\nнаписать в мессенджер 21.09"
-   **Ожидаемый JSON-ответ:**
    ```json
    [
      {{
        "task": "Отправить коммерческое предложение",
        "date_time": "2025-09-16 10:00",
        "marked_line": "отправить коммерческое предложение завтра"
      }},
      {{
        "task": "Написать в мессенджер",
        "date_time": "2025-09-21 10:00",
        "marked_line": "написать в мессенджер 21.09"
      }}
    ]
    ```

**Пример 3 (Задача для другого отдела — игнорирование):**
-   **Входной текст:** "За 10 мин до прибытия на место позвонить\nОбед с 13 до 14\nУдобрен для декор ливств"
-   **Ожидаемый JSON-ответ:**
    ```json
    []
    ```

**Пример 4 (Прошедшая дата — игнорирование):**
-   **Входной текст:** "Встреча 11.09\nнет связи"
-   **Ожидаемый JSON-ответ:**
    ```json
    []
    ```

**Пример 5 (Статус — отправлено КП):**
-   **Входной текст:** "22/09 - направлено кп на согласование"
-   **Ожидаемый JSON-ответ:**
    ```json
    []
    ```

**Пример 6 (Завершённое действие — игнорирование):**
-   **Входной текст:** "нолину уже забрали"
-   **Ожидаемый JSON-ответ:**
    ```json
    []
    ```

**Пример 7 (Описание без задачи — игнорирование):**
-   **Входной текст:** "нет цикаса и оваты сансет"
-   **Ожидаемый JSON-ответ:**
    ```json
    []
    ```

**Пример 8 (Статус — игнорирование):**
-   **Входной текст:** "спам"
-   **Ожидаемый JSON-ответ:**
    ```json
    []
    ```

**Пример 9 (Слова-синонимы: кас):**
-   **Входной текст:** "кас 16.09"
-   **Ожидаемый JSON-ответ:**
    ```json
    [
      {{
        "task": "Связаться с клиентом",
        "date_time": "2025-09-16 10:00",
        "marked_line": "кас 16.09"
      }}
    ]
    ```

**Пример 10 (Слова-синонимы: след кас):**
-   **Входной текст:** "след кас 24.09"
-   **Ожидаемый JSON-ответ:**
    ```json
    [
      {{
        "task": "Связаться с клиентом",
        "date_time": "2025-09-24 10:00",
        "marked_line": "след кас 24.09"
      }}
    ]
    ```

Твой ответ должен содержать только один JSON-объект, который является массивом.
"""
    try:
        response = openai.chat.completions.create(
            model="gpt-4o-mini",
            response_format={"type": "json_object"},
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": comment}
            ]
        )

        raw_content = response.choices[0].message.content

        # Проверяем, что raw_content не None, прежде чем обрабатывать его
        if raw_content is None:
            raw_content = ""

        print(f"Сырой ответ от OpenAI: ```json\n{raw_content}\n```")

        # Удаляем лишние символы из ответа, если они есть
        clean_content = re.sub(r'```json\n|```', '', raw_content).strip()

        # Загружаем JSON-данные
        parsed_data = json.loads(clean_content)

        if isinstance(parsed_data, list):
            return [item for item in parsed_data if item.get('task') and item.get('date_time')]
        elif isinstance(parsed_data, dict):
            if parsed_data.get('response') is not None:
                if isinstance(parsed_data.get('response'), list):
                    return [item for item in parsed_data['response'] if item.get('task') and item.get('date_time')]
                else:
                    return []
            elif parsed_data.get('task') and parsed_data.get('date_time'):
                return [parsed_data]
            else:
                return []
        else:
            print("Ошибка: Неожиданный формат ответа от OpenAI.")
            return []

    except json.JSONDecodeError as e:
        print(f"Ошибка декодирования JSON: {e}. Сырой контент: {clean_content}")
        return []
    except openai.APIError as e:
        print(f"Ошибка при запросе к OpenAI API: {e}")
        return []