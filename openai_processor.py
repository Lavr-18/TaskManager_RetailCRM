import os
import openai
import json
import re
from datetime import datetime
from dotenv import load_dotenv
from typing import List, Dict, Any

load_dotenv()

# Устанавливаем ключ API из переменных окружения
openai.api_key = os.getenv('OPENAI_API_KEY')


def analyze_comment_with_openai(comment: str) -> List[Dict[str, Any]]:
    """
    Отправляет комментарий на анализ в OpenAI и возвращает список найденных задач
    в виде JSON-объектов.
    """
    if not openai.api_key:
        print("Ошибка: Ключ OpenAI API не установлен.")
        return []

    # Получаем текущую дату и время для промпта
    current_datetime_str = datetime.now().strftime("%Y-%m-%d %H:%M")

    system_prompt = f"""
Ты — продвинутый ассистент, CRM-менеджер-помощник. Твоя основная задача — анализировать комментарии и сообщения, оставленные менеджерами в CRM-системе, и извлекать из них будущие задачи для автоматической постановки.

## Инструкции по анализу
1.  **Роль**: Ты должен найти в тексте только те записи, которые являются явными будущими задачами.
2.  **Игнорирование**: Полностью игнорируй любые записи, которые не требуют будущих действий, например:
    -   Уже произошедшие события (описания прошедших звонков, встреч).
    -   Статусы заказа ("дубль заказа", "закрыл", "продал").
    -   Описания без привязки ко времени ("обратной связи нет", "бросила трубку").
3.  **Год**: Для всех дат используй текущий год (`{datetime.now().year}`), если год не указан в тексте.
4.  **Время**: Если в тексте не указано конкретное время, используй стандартное время 10:00.

## Формат ответа
Твой ответ должен быть **исключительно** в формате JSON-массива. Каждый объект в массиве должен иметь следующие три поля:
-   `task`: Краткое описание задачи (например, "Перезвонить", "Отправить КП", "Связаться с клиентом").
-   `date_time`: Дата и время выполнения задачи в строгом формате `ГГГГ-ММ-ДД ЧЧ:ММ`. Для относительных дат (`завтра`, `через 3 дня`) используй текущую дату (`{current_datetime_str}`) для расчёта.
-   `marked_line`: Точная строка из исходного текста, которая содержит эту задачу.

Если в тексте нет ни одной подходящей будущей задачи, верни пустой JSON-массив: `[]`.

## Примеры для обучения
**Пример 1 (Задача найдена):**
-   **Входной текст:** "Заказ № 11234\nперезвонить через 3 дня\nотменил заказ"
-   **Ожидаемый JSON-ответ:**
    ```json
    [
      {{
        "task": "Перезвонить",
        "date_time": "2025-09-18 10:00",
        "marked_line": "перезвонить через 3 дня"
      }}
    ]
    ```

**Пример 2 (Несколько задач):**
-   **Входной текст:** "Клиент попросил отправить коммерческое предложение завтра\nнаписать в мессенджер 21.09"
-   **Ожидаемый JSON-ответ:**
    ```json
    [
      {{
        "task": "Отправить коммерческое предложение",
        "date_time": "2025-09-16 10:00",
        "marked_line": "отправить коммерческое предложение завтра"
      }},
      {{
        "task": "Написать в мессенджер",
        "date_time": "2025-09-21 10:00",
        "marked_line": "написать в мессенджер 21.09"
      }}
    ]
    ```

**Пример 3 (Игнорирование):**
-   **Входной текст:** "Встреча 11.09\nнет связи"
-   **Ожидаемый JSON-ответ:**
    ```json
    []
    ```

Твой ответ должен содержать только один JSON-объект, который является массивом.
"""

    try:
        response = openai.chat.completions.create(
            model="gpt-4o-mini",
            response_format={"type": "json_object"},
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": comment}
            ]
        )

        raw_content = response.choices[0].message.content
        print(f"Сырой ответ от OpenAI: ```json\n{raw_content}\n```")

        # Удаляем лишние символы из ответа, если они есть
        clean_content = re.sub(r'```json\n|```', '', raw_content).strip()

        # Загружаем JSON-данные
        parsed_data = json.loads(clean_content)

        # Новая логика: преобразуем ответ в список, если он не является им
        if isinstance(parsed_data, dict):
            # Если это пустой словарь, возвращаем пустой список
            if not parsed_data:
                return []
            # Если это словарь с одной задачей, оборачиваем его в список
            return [parsed_data]
        elif isinstance(parsed_data, list):
            # Если это уже список, возвращаем его как есть
            return parsed_data
        else:
            # Если формат ответа неизвестен, возвращаем пустой список
            print("Ошибка: Неожиданный формат ответа от OpenAI.")
            return []

    except json.JSONDecodeError as e:
        print(f"Ошибка декодирования JSON: {e}")
        return []
    except openai.APIError as e:
        print(f"Ошибка при запросе к OpenAI API: {e}")
        return []